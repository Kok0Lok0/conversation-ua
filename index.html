<!DOCTYPE html>

<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Питання для друзів</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400&family=Inter:wght@400&display=swap');

```
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #faf8f6;
  color: #1a1a1a;
  font-family: 'Inter', -apple-system, sans-serif;
}

.app {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: max(env(safe-area-inset-top), 48px) 24px max(env(safe-area-inset-bottom), 48px);
}

.header {
  text-align: center;
  margin-bottom: 24px;
}

.header h1 {
  font-family: 'Inter', sans-serif;
  font-size: 0.875rem;
  font-weight: 400;
  opacity: 0.5;
  margin-bottom: 8px;
}

.header p {
  font-family: 'Inter', sans-serif;
  font-size: 0.8125rem;
  font-weight: 400;
  opacity: 0.45;
}

.question-container {
  flex: 1;
  width: 100%;
  max-width: 640px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 8vh;
  padding-left: 0;
  padding-right: 0;
  position: relative;
  touch-action: none;
}

.question-wrapper {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  transition: none;
  padding: 0;
}

.question-text {
  font-family: 'Source Serif 4', Georgia, serif;
  font-size: clamp(1.75rem, 5vw, 2.5rem);
  font-weight: 400;
  line-height: 1.4;
  text-align: center;
  width: 80%;
  margin: 0 auto 32px auto;
  padding: 0;
}

.horse-illustration {
  width: auto;
  max-height: 30vh;
  opacity: 0;
  animation: fadeInHorse 300ms ease-out forwards;
  margin-left: 12px;
  margin-bottom: 32px;
}

@keyframes fadeInHorse {
  from { opacity: 0; }
  to { opacity: 1; }
}

.actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  width: 100%;
  max-width: 400px;
  padding: 0 20px;
}

.action-button {
  font-family: 'Inter', sans-serif;
  font-size: 0.875rem;
  font-weight: 400;
  padding: 14px 28px;
  border: 1px solid rgba(26, 26, 26, 0.15);
  background: transparent;
  cursor: pointer;
  transition: all 200ms ease;
  flex: 1;
}

.action-button.skip {
  color: rgba(26, 26, 26, 0.45);
  border-color: rgba(26, 26, 26, 0.12);
}

.action-button.skip:hover {
  border-color: rgba(26, 26, 26, 0.25);
  color: rgba(26, 26, 26, 0.6);
}

.action-button.discuss {
  color: #1a1a1a;
  border-color: #1a1a1a;
}

.action-button.discuss:hover {
  background: #1a1a1a;
  color: #faf8f6;
}

.action-button:active {
  transform: scale(0.98);
}

.hint {
  position: absolute;
  bottom: 24px;
  left: 0;
  right: 0;
  text-align: center;
  font-family: 'Inter', sans-serif;
  font-size: 0.8125rem;
  font-weight: 400;
  opacity: 0.4;
  transition: opacity 300ms ease-out;
}

.hint.hidden {
  opacity: 0;
  pointer-events: none;
}

.end-screen {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  max-width: 480px;
}

.end-screen h2 {
  font-family: 'Source Serif 4', Georgia, serif;
  font-size: 1.5rem;
  font-weight: 400;
  line-height: 1.4;
  margin-bottom: 24px;
}

.end-screen p {
  font-family: 'Inter', sans-serif;
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5;
  opacity: 0.7;
  margin-bottom: 48px;
}

.button {
  font-family: 'Inter', sans-serif;
  font-size: 0.9375rem;
  font-weight: 400;
  padding: 16px 32px;
  background: #1a1a1a;
  color: #faf8f6;
  border: none;
  cursor: pointer;
  margin-bottom: 16px;
  transition: opacity 200ms ease;
}

.button:hover {
  opacity: 0.85;
}

.button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.button.secondary {
  background: transparent;
  color: #1a1a1a;
  opacity: 0.5;
}

.button.secondary:hover {
  opacity: 0.7;
}

.loading-screen {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.loading-screen p {
  font-family: 'Inter', sans-serif;
  font-size: 0.9375rem;
  font-weight: 400;
  opacity: 0.6;
}
```

  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const horses = [
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M60,50 Q65,45 70,48 L75,52 Q78,48 82,52 L85,58 Q88,62 90,68 L92,80 Q93,90 92,100 L90,110 L88,120 L85,115 L82,110 L80,120 L78,130 L77,145 L76,160 L75,170 M85,115 L87,125 L88,135 L89,150 L90,165 L91,175 M60,100 L58,110 L57,125 L56,140 L55,155 L54,170 M70,100 L68,115 L67,130 L66,145 L65,160 L64,172" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M55,52 Q60,48 65,50 L70,54 Q73,50 77,54 L80,60 Q83,64 85,70 L87,82 Q88,92 87,102 L85,112 L83,122 L80,117 L77,112 L75,122 L73,132 L72,140 L71,150 M80,117 L82,127 L83,137 L84,145 L85,155 M55,102 L53,112 L52,122 L51,132 L52,145 M65,102 L63,117 L62,127 L63,140 L64,152" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M80,60 Q85,55 90,58 L95,62 Q98,58 102,62 L105,68 Q108,75 110,85 L108,95 Q105,100 100,102 L95,103 Q90,104 85,102 L80,98 Q75,92 74,85 L75,75 Q77,68 80,60 M95,62 L96,68 M102,65 L103,70" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M70,55 Q75,50 80,53 L85,57 Q88,53 92,57 L95,63 Q98,67 100,73 L102,85 Q103,95 102,105 L100,115 L98,125 L95,120 L92,115 L90,125 L88,135 L87,148 L86,163 M95,120 L97,130 L98,140 L99,153 L100,165 M70,105 L68,115 L67,128 L66,143 L65,158 M80,105 L78,120 L77,135 L76,150 L75,163" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`
    ];

    const initialQuestions = [
      // Про просте і щоденне
      { text: "Яка дрібна річ робить твій день кращим майже завжди?", category: "daily" },
      { text: "Що з простого життя ти цінуєш більше, ніж здається ззовні?", category: "daily" },
      { text: "Коли ты востаннє відчував тиху радість без особливої причини?", category: "daily" },
      { text: "Що допомагає тобі заспокоїтись, коли всередині шумно?", category: "daily" },
      { text: "Який момент за останній час хочеться згадувати знову і знову?", category: "daily" },
      { text: "Що в твоєму житті зараз дає відчуття стабільності?", category: "daily" },
      { text: "Яку частину дня ты любиш найбільше — і за що?", category: "daily" },
      { text: "Коли ты востаннє дозволив собі просто бути, без планів?", category: "daily" },
      
      // Про людей
      { text: "Хто з'явився у твоєму житті несподівано, але дуже влучно?", category: "people" },
      { text: "З ким у твоєму житті завжди трохи тепліше?", category: "people" },
      { text: "Кого ты згадуєш, коли тобі важко?", category: "people" },
      { text: "З ким тобі легко бути собою, навіть без розмов?", category: "people" },
      { text: "Яка розмова з кимось залишилась у тобі надовго?", category: "people" },
      { text: "Хто навчив тебе чомусь важливому, сам того не знаючи?", category: "people" },
      { text: "Поруч із якими людьми ты відчуваєш себе спокійно?", category: "people" },
      { text: "Коли ты востаннє відчував щиру людську підтримку?", category: "people" },
      
      // Про спогади
      { text: "Який запах або звук миттєво повертає тебе в минуле?", category: "memories" },
      { text: "Який спогад живе в тобі не образами, а відчуттям?", category: "memories" },
      { text: "Є місце, яке для тебе завжди буде \"домом\", навіть якщо ты там давно не був?", category: "memories" },
      { text: "Яку просту сцену з минулого ты часто згадуєш?", category: "memories" },
      { text: "Який період життя був тихим, але дуже важливим для тебе?", category: "memories" },
      { text: "Про який спогад ты рідко розповідаєш, але він для тебе цінний?", category: "memories" },
      { text: "Яка дрібниця з минулого досі має для тебе значення?", category: "memories" },
      { text: "Що з дитинства залишилось у тобі до сьогодні?", category: "memories" },
      
      // Про себе
      { text: "Що в собі ты навчився цінувати з часом?", category: "self" },
      { text: "Є щось, що ты довго не помічав у собі, а тепер помічаєш?", category: "self" },
      { text: "Що в тобі залишилось незмінним, попри всі зміни?", category: "self" },
      { text: "За що ты можеш бути вдячний собі сьогодні?", category: "self" },
      { text: "Що в тобі хочеться берегти?", category: "self" },
      { text: "Коли ты відчуваєш, що живеш \"правильно\" для себе?", category: "self" }
    ];

    function App() {
      const [questions, setQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [preferences, setPreferences] = useState({});
      const [showHint, setShowHint] = useState(true);
      const [isGenerating, setIsGenerating] = useState(false);
      const [isDragging, setIsDragging] = useState(false);
      const [dragY, setDragY] = useState(0);
      const [startY, setStartY] = useState(0);
      
      const QUESTIONS_PER_ROUND = 10;
      const SWIPE_THRESHOLD = 80;

      useEffect(() => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        
        const saved = localStorage.getItem('questionPreferences');
        if (saved) {
          setPreferences(JSON.parse(saved));
        }
        
        const handleKeyDown = (e) => {
          if (e.key === 'ArrowDown' || e.key === ' ') {
            e.preventDefault();
            handleNext(true);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            handleNext(false);
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      useEffect(() => {
        if (Object.keys(preferences).length > 0) {
          localStorage.setItem('questionPreferences', JSON.stringify(preferences));
        }
      }, [preferences]);

      const recordPreference = (question, liked) => {
        const categoryScores = { ...preferences };
        if (liked) {
          categoryScores[question.category] = (categoryScores[question.category] || 0) + 1;
        }
        setPreferences(categoryScores);
        
        // Log for debugging
        console.log('Recorded preference:', {
          question: question.text,
          category: question.category,
          liked,
          currentScores: categoryScores
        });
      };

      const handleNext = (liked) => {
        if (currentIndex >= questions.length) return;
        
        setShowHint(false);
        const currentQuestion = questions[currentIndex];
        recordPreference(currentQuestion, liked);
        setCurrentIndex(prev => prev + 1);
      };

      const handleTouchStart = (e) => {
        setIsDragging(true);
        setStartY(e.touches[0].clientY);
      };

      const handleTouchMove = (e) => {
        if (!isDragging) return;
        const currentY = e.touches[0].clientY;
        const delta = currentY - startY;
        setDragY(delta * 0.7);
      };

      const handleTouchEnd = () => {
        setIsDragging(false);
        
        if (Math.abs(dragY) > SWIPE_THRESHOLD) {
          if (dragY > 0) {
            handleNext(true);
          } else {
            handleNext(false);
          }
        }
        
        setDragY(0);
      };

      const handleWheel = (e) => {
        e.preventDefault();
        if (Math.abs(e.deltaY) > 20) {
          if (e.deltaY > 0) {
            handleNext(true);
          } else {
            handleNext(false);
          }
        }
      };

      const generateNewQuestions = async () => {
        setIsGenerating(true);
        const startTime = Date.now();
        
        try {
          // Get all liked questions from this round
          const likedQuestions = [];
          const completedQuestions = questions.slice(0, currentIndex);
          
          console.log('Generating based on preferences:', preferences);
          console.log('Completed questions:', completedQuestions.length);
          
          // Sort categories by preference
          const sortedCategories = Object.entries(preferences)
            .sort((a, b) => b[1] - a[1])
            .map(([cat]) => cat);

          console.log('Preferred categories:', sortedCategories);

          // Collect actual liked questions
          for (const question of completedQuestions) {
            if (preferences[question.category] > 0) {
              likedQuestions.push(question.text);
            }
          }

          const categoryContext = sortedCategories.length > 0 
            ? `Користувач найбільше любить питання про: ${sortedCategories.join(', ')}.`
            : 'Користувач тільки почав відповідати на питання.';

          const exampleQuestions = likedQuestions.slice(0, 5);

          console.log('Sending to API - liked questions:', exampleQuestions);

          const prompt = `Ти помічник, який створює питання для розмов між друзями українською мовою.

${categoryContext}

${exampleQuestions.length > 0 ? `Ось приклади питань, які сподобались:
${exampleQuestions.map(q => `- ${q}`).join('\n')}` : ''}

Створи 10 нових унікальних питань українською мовою, які:
1. Схожі за стилем і тематикою${exampleQuestions.length > 0 ? ' на приклади вище' : ''}
2. Спокійні, вдумливі, про прості речі в житті
3. Викликають щирі розмови між друзями
4. Не повторюються з існуючими

Відповідай ТІЛЬКИ у форматі JSON масиву:
[{"text":"Питання тут?","category":"daily"}]

Використовуй ці категорії: daily, people, memories, self`;

          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            console.error('API request failed:', response.status);
            throw new Error('API failed');
          }

          const data = await response.json();
          console.log('API response:', data);
          
          const responseText = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanedText = responseText.replace(/```json|```/g, '').trim();
          console.log('Cleaned response:', cleanedText);
          
          const newQuestions = JSON.parse(cleanedText);
          
          const elapsed = Date.now() - startTime;
          if (elapsed < 800) {
            await new Promise(resolve => setTimeout(resolve, 800 - elapsed));
          }
          
          if (Array.isArray(newQuestions) && newQuestions.length > 0) {
            console.log('Generated questions:', newQuestions);
            setQuestions(newQuestions.slice(0, QUESTIONS_PER_ROUND));
            setCurrentIndex(0);
            setShowHint(false);
          } else {
            throw new Error('Invalid response format');
          }
        } catch (error) {
          console.error('Generation error:', error);
          // Fallback: use preference-weighted shuffle
          const weightedQuestions = [...initialQuestions];
          
          // If we have preferences, prioritize those categories
          if (Object.keys(preferences).length > 0) {
            const sortedByPreference = weightedQuestions.sort((a, b) => {
              const scoreA = preferences[a.category] || 0;
              const scoreB = preferences[b.category] || 0;
              if (scoreA !== scoreB) return scoreB - scoreA;
              return Math.random() - 0.5;
            });
            setQuestions(sortedByPreference.slice(0, QUESTIONS_PER_ROUND));
          } else {
            const shuffled = weightedQuestions.sort(() => Math.random() - 0.5);
            setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
          }
          
          setCurrentIndex(0);
        } finally {
          setIsGenerating(false);
        }
      };

      const startNewRound = () => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        setCurrentIndex(0);
        setShowHint(false);
      };

      if (isGenerating) {
        return (
          <div className="app">
            <div className="loading-screen">
              <p>Добираємо питання для цієї розмови…</p>
            </div>
          </div>
        );
      }

      if (currentIndex >= questions.length) {
        const topCategories = Object.entries(preferences)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 2)
          .map(([cat]) => {
            const names = {
              daily: 'щоденне',
              people: 'людей', 
              memories: 'спогади',
              self: 'себе'
            };
            return names[cat] || cat;
          });
        
        return (
          <div className="app">
            <div className="header">
              <h1>Питання для друзів</h1>
            </div>
            <div className="end-screen">
              <h2>Це було 10 питань.</h2>
              {topCategories.length > 0 && (
                <p>Вам найбільше зайшли теми про {topCategories.join(' та ')}.</p>
              )}
              <p>Хочеш ще — схожих на ті, що вам зайшли?</p>
              <button className="button" onClick={generateNewQuestions}>
                Згенерувати ще 10
              </button>
              <button className="button secondary" onClick={startNewRound}>
                Досить на сьогодні
              </button>
            </div>
          </div>
        );
      }

      const currentQuestion = questions[currentIndex];
      const horseIndex = currentIndex % horses.length;
      const opacity = isDragging ? Math.max(0.95, 1 - Math.abs(dragY) / 500) : 1;
      
      return (
        <div className="app">
          <div className="header">
            <h1>Питання для друзів</h1>
            <p>{currentIndex + 1} з {QUESTIONS_PER_ROUND}</p>
          </div>
          
          <div className="question-container">
            <div 
              className="question-wrapper"
              onTouchStart={handleTouchStart}
              onTouchMove={handleTouchMove}
              onTouchEnd={handleTouchEnd}
              onWheel={handleWheel}
              style={{
                transform: `translateY(${dragY}px)`,
                opacity: opacity,
                transition: isDragging ? 'none' : 'transform 400ms ease-out, opacity 400ms ease-out'
              }}
            >
              <div className="question-text">
                {currentQuestion?.text}
              </div>
              
              <div 
                className="horse-illustration"
                key={currentIndex}
                dangerouslySetInnerHTML={{ __html: horses[horseIndex] }}
              />
              
              <div className="actions">
                <button 
                  className="action-button skip" 
                  onClick={() => handleNext(false)}
                >
                  Пропустити
                </button>
                <button 
                  className="action-button discuss" 
                  onClick={() => handleNext(true)}
                >
                  Обговорити
                </button>
              </div>
            </div>
          </div>
          
          {showHint && (
            <div className="hint">
              Проведи вниз, щоб перейти далі
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

</body>
</html>