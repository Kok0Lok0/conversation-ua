<!DOCTYPE html>

<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Питання для друзів</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

```
:root {
  --bg-primary: #0a0a0a;
  --bg-secondary: #111111;
  --bg-card: #1a1a1a;
  --text-primary: #ffffff;
  --text-secondary: #a0a0a0;
  --accent: #ffffff;
  --accent-green: #10b981;
  --accent-red: #ef4444;
  --border: rgba(255, 255, 255, 0.1);
  --shadow: rgba(0, 0, 0, 0.5);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  overflow-x: hidden;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.container {
  max-width: 440px;
  margin: 0 auto;
  padding: 40px 20px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.header {
  text-align: center;
  margin-bottom: 48px;
}

.header h1 {
  font-size: 2rem;
  font-weight: 700;
  color: var(--text-primary);
  margin-bottom: 8px;
  letter-spacing: -0.02em;
}

.header p {
  font-size: 0.875rem;
  color: var(--text-secondary);
  font-weight: 500;
}

.card-container {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  perspective: 1000px;
  position: relative;
  margin-bottom: 32px;
}

.question-card {
  width: 100%;
  max-width: 400px;
  min-height: 480px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 24px;
  padding: 48px 32px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  position: relative;
  cursor: grab;
  user-select: none;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  transform-origin: center center;
}

.question-card:hover {
  border-color: rgba(255, 255, 255, 0.2);
}

.question-card.dragging {
  cursor: grabbing;
}

.question-number {
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--text-secondary);
  margin-bottom: 32px;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.question-text {
  font-size: 1.5rem;
  line-height: 1.5;
  color: var(--text-primary);
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 500;
  letter-spacing: -0.01em;
}

.swipe-indicators {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  display: flex;
  justify-content: space-between;
  padding: 0 40px;
  pointer-events: none;
  z-index: 10;
}

.swipe-label {
  font-size: 2rem;
  font-weight: 700;
  opacity: 0;
  transition: opacity 0.2s ease;
  letter-spacing: -0.02em;
}

.swipe-label.dislike {
  color: var(--accent-red);
}

.swipe-label.like {
  color: var(--accent-green);
}

.swipe-label.visible {
  opacity: 1;
}

.controls {
  text-align: center;
  margin-bottom: 24px;
}

.swipe-buttons {
  display: flex;
  justify-content: center;
  gap: 16px;
}

.swipe-button {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.5rem;
  border: 1px solid var(--border);
  background: var(--bg-card);
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}

.swipe-button:hover {
  border-color: var(--accent);
  transform: scale(1.05);
}

.swipe-button:active {
  transform: scale(0.95);
}

.swipe-button.dislike:hover {
  border-color: var(--accent-red);
  color: var(--accent-red);
}

.swipe-button.like:hover {
  border-color: var(--accent-green);
  color: var(--accent-green);
}

.stats {
  text-align: center;
  padding: 20px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
}

.stats p {
  font-size: 0.875rem;
  color: var(--text-secondary);
  margin-bottom: 16px;
}

.button {
  display: inline-block;
  padding: 12px 24px;
  font-size: 0.875rem;
  font-weight: 600;
  font-family: 'Inter', sans-serif;
  background: var(--accent);
  color: var(--bg-primary);
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
  margin: 4px;
}

.button:hover {
  transform: translateY(-1px);
  box-shadow: 0 8px 24px rgba(255, 255, 255, 0.15);
}

.button:active {
  transform: translateY(0);
}

.button:disabled {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  cursor: not-allowed;
  transform: none;
}

.button.secondary {
  background: transparent;
  color: var(--text-primary);
  border: 1px solid var(--border);
}

.button.secondary:hover {
  border-color: var(--accent);
}

@media (max-width: 480px) {
  .container {
    padding: 32px 16px;
  }
  
  .header h1 {
    font-size: 1.75rem;
  }
  
  .question-text {
    font-size: 1.25rem;
  }
  
  .question-card {
    min-height: 420px;
    padding: 40px 24px;
  }
  
  .swipe-button {
    width: 56px;
    height: 56px;
  }
}
```

  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const initialQuestions = [
      { text: "Яка твоя найбезглуздіша мрія?", category: "dreams" },
      { text: "Що б ти змінив у своєму житті, якби міг?", category: "life" },
      { text: "Який був твій найсміливіший вчинок?", category: "experiences" },
      { text: "Що тебе справді лякає?", category: "fears" },
      { text: "Яку суперсилу ти б хотів мати і чому?", category: "dreams" },
      { text: "Який момент зі свого минулого ти б хотів пережити знову?", category: "memories" },
      { text: "Що для тебе означає справжня дружба?", category: "relationships" },
      { text: "Яка книга чи фільм змінили твій погляд на світ?", category: "culture" },
      { text: "Про що ти найчастіше мріяєш?", category: "dreams" },
      { text: "Який найцінніший урок ти отримав від невдачі?", category: "growth" },
      { text: "Що приносить тобі найбільше задоволення в житті?", category: "happiness" },
      { text: "Якби ти міг поговорити з собою в минулому, що б ти порадив?", category: "wisdom" },
      { text: "Яке твоє найяскравіше дитяче спогад?", category: "memories" },
      { text: "Що робить тебе унікальним?", category: "identity" },
      { text: "Якою людиною ти хочеш стати через 10 років?", category: "future" },
      { text: "Що тебе надихає продовжувати, коли важко?", category: "motivation" },
      { text: "Який найкращий комплімент ти коли-небудь отримував?", category: "relationships" },
      { text: "Що ти б зробив, якби знав, що не зазнаєш невдачі?", category: "courage" },
      { text: "Яка твоя таємна пристрасть?", category: "interests" },
      { text: "Який найскладніший вибір ти коли-небудь робив?", category: "decisions" },
      { text: "Що змушує тебе почуватися живим?", category: "emotions" },
      { text: "Якби у тебе був один день без обмежень, як би ти його провів?", category: "dreams" },
      { text: "Яка традиція чи звичка найбільше тобі подобається?", category: "culture" },
      { text: "Що тебе дивує в людях?", category: "observations" },
      { text: "Який найдобріший вчинок хтось коли-небудь зробив для тебе?", category: "kindness" },
      { text: "Про що ти ніколи не пошкодуєш?", category: "values" },
      { text: "Яка подія найбільше вплинула на те, ким ти є сьогодні?", category: "growth" },
      { text: "Що б ти хотів, щоб люди знали про тебе?", category: "identity" },
      { text: "Який талант ти б хотів розвинути?", category: "aspirations" },
      { text: "Що для тебе означає успіх?", category: "values" },
      { text: "Яке місце на планеті ти мрієш відвідати?", category: "travel" },
      { text: "Що робить тебе щасливим прямо зараз?", category: "happiness" },
      { text: "Який урок ти хотів би передати іншим?", category: "wisdom" },
      { text: "Що тебе найбільше хвилює щодо майбутнього?", category: "future" },
      { text: "Яку пісню ти б обрав як саундтрек свого життя?", category: "culture" },
      { text: "Що ти цінуєш у собі найбільше?", category: "self" },
      { text: "Який найдивніший досвід у тебе був?", category: "experiences" },
      { text: "Що б ти хотів сказати людині, яка тобі важлива?", category: "relationships" },
      { text: "Яка твоя найбільша перемога над собою?", category: "growth" },
      { text: "Що змушує тебе сміятися до сліз?", category: "humor" }
    ];

    function App() {
      const [questions, setQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [likes, setLikes] = useState(0);
      const [dislikes, setDislikes] = useState(0);
      const [preferences, setPreferences] = useState({});
      const [isDragging, setIsDragging] = useState(false);
      const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
      const [swipeDirection, setSwipeDirection] = useState(null);
      const [isGenerating, setIsGenerating] = useState(false);
      
      const cardRef = useRef(null);
      const startPosRef = useRef({ x: 0, y: 0 });

      useEffect(() => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled);
        
        const saved = localStorage.getItem('questionPreferences');
        if (saved) {
          setPreferences(JSON.parse(saved));
        }
      }, []);

      useEffect(() => {
        if (Object.keys(preferences).length > 0) {
          localStorage.setItem('questionPreferences', JSON.stringify(preferences));
        }
      }, [preferences]);

      const getNextQuestions = (likedCategory) => {
        const categoryScores = { ...preferences };
        
        if (likedCategory) {
          categoryScores[likedCategory] = (categoryScores[likedCategory] || 0) + 1;
        }
        
        setPreferences(categoryScores);
        
        const remaining = initialQuestions.filter(q => 
          !questions.slice(0, currentIndex + 1).includes(q)
        );
        
        const sorted = remaining.sort((a, b) => {
          const scoreA = categoryScores[a.category] || 0;
          const scoreB = categoryScores[b.category] || 0;
          return scoreB - scoreA;
        });
        
        const topQuestions = sorted.slice(0, 10);
        const shuffled = topQuestions.sort(() => Math.random() - 0.5);
        
        return [...questions.slice(0, currentIndex + 1), ...shuffled, ...sorted.slice(10)];
      };

      const handleSwipe = (direction) => {
        const currentQuestion = questions[currentIndex];
        
        if (direction === 'right') {
          setLikes(prev => prev + 1);
          const updated = getNextQuestions(currentQuestion.category);
          setQuestions(updated);
        } else {
          setDislikes(prev => prev + 1);
        }
        
        setCurrentIndex(prev => prev + 1);
        setDragOffset({ x: 0, y: 0 });
        setSwipeDirection(null);
      };

      const handleStart = (e) => {
        setIsDragging(true);
        const clientX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
        const clientY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
        startPosRef.current = { x: clientX, y: clientY };
      };

      const handleMove = (e) => {
        if (!isDragging) return;
        
        const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
        const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
        
        const deltaX = clientX - startPosRef.current.x;
        const deltaY = clientY - startPosRef.current.y;
        
        setDragOffset({ x: deltaX, y: deltaY });
        
        if (Math.abs(deltaX) > 50) {
          setSwipeDirection(deltaX > 0 ? 'right' : 'left');
        } else {
          setSwipeDirection(null);
        }
      };

      const handleEnd = () => {
        setIsDragging(false);
        
        if (Math.abs(dragOffset.x) > 100) {
          handleSwipe(dragOffset.x > 0 ? 'right' : 'left');
        } else {
          setDragOffset({ x: 0, y: 0 });
          setSwipeDirection(null);
        }
      };

      const generateNewQuestions = async () => {
        setIsGenerating(true);
        
        try {
          const sortedCategories = Object.entries(preferences)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([cat]) => cat);

          const categoryContext = sortedCategories.length > 0 
            ? `Користувач найбільше любить питання про: ${sortedCategories.join(', ')}.`
            : '';

          const sampleQuestions = questions
            .filter(q => sortedCategories.includes(q.category))
            .slice(0, 5)
            .map(q => q.text);

          const prompt = `Ти помічник, який створює питання для розмов між друзями українською мовою.

${categoryContext}

Ось приклади питань, які сподобались користувачу:
${sampleQuestions.map(q => `- ${q}`).join('\n')}

Створи 40 нових унікальних питань українською мовою для друзів, які:
1. Схожі за стилем і тематикою на приклади вище
2. Викликають глибокі розмови
3. Не повторюються з існуючими
4. Підходять для компанії друзів

ВАЖЛИВО: Відповідай ТІЛЬКИ у форматі JSON масиву об'єктів, без жодного додаткового тексту, пояснень чи markdown коду. Формат:
[{"text":"Питання тут?","category":"dreams"},{"text":"Ще питання?","category":"life"}]

Використовуй ці категорії: dreams, life, experiences, fears, memories, relationships, culture, growth, happiness, wisdom, identity, future, motivation, courage, interests, decisions, emotions, observations, kindness, values, aspirations, travel, self, humor`;

          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [
                { role: 'user', content: prompt }
              ]
            })
          });

          const data = await response.json();
          const responseText = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanedText = responseText
            .replace(/```json/g, '')
            .replace(/```/g, '')
            .trim();

          const newQuestions = JSON.parse(cleanedText);
          
          if (Array.isArray(newQuestions) && newQuestions.length > 0) {
            setQuestions(newQuestions);
            setCurrentIndex(0);
            setLikes(0);
            setDislikes(0);
          } else {
            throw new Error('Invalid response format');
          }
        } catch (error) {
          console.error('Error generating questions:', error);
          alert('Помилка при генерації питань. Спробуйте ще раз.');
        } finally {
          setIsGenerating(false);
        }
      };

      if (currentIndex >= questions.length) {
        return (
          <div className="container">
            <div className="header">
              <h1>Готово</h1>
              <p>Ти переглянув усі питання</p>
            </div>
            <div className="stats">
              <p>Вподобано: {likes} • Пропущено: {dislikes}</p>
              
              <button 
                onClick={generateNewQuestions}
                disabled={isGenerating}
                className="button"
              >
                {isGenerating ? 'Генерую...' : 'Згенерувати нові питання'}
              </button>

              <button 
                onClick={() => {
                  const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
                  setQuestions(shuffled);
                  setCurrentIndex(0);
                  setLikes(0);
                  setDislikes(0);
                }}
                className="button secondary"
              >
                Почати знову
              </button>
            </div>
          </div>
        );
      }

      const currentQuestion = questions[currentIndex];
      const rotation = dragOffset.x * 0.03;
      const opacity = 1 - Math.abs(dragOffset.x) / 300;

      return (
        <div className="container">
          <div className="header">
            <h1>Питання для друзів</h1>
            <p>Смахни вправо або вліво</p>
          </div>

          <div className="card-container">
            <div
              ref={cardRef}
              className={`question-card ${isDragging ? 'dragging' : ''}`}
              style={{
                transform: `translate(${dragOffset.x}px, ${dragOffset.y}px) rotate(${rotation}deg)`,
                opacity: opacity
              }}
              onMouseDown={handleStart}
              onMouseMove={handleMove}
              onMouseUp={handleEnd}
              onMouseLeave={handleEnd}
              onTouchStart={handleStart}
              onTouchMove={handleMove}
              onTouchEnd={handleEnd}
            >
              <div className="question-number">
                {currentIndex + 1} / {questions.length}
              </div>
              <div className="question-text">
                {currentQuestion?.text}
              </div>
            </div>

            <div className="swipe-indicators">
              <div className={`swipe-label dislike ${swipeDirection === 'left' ? 'visible' : ''}`}>
                НІ
              </div>
              <div className={`swipe-label like ${swipeDirection === 'right' ? 'visible' : ''}`}>
                ТАК
              </div>
            </div>
          </div>

          <div className="controls">
            <div className="swipe-buttons">
              <button className="swipe-button dislike" onClick={() => handleSwipe('left')}>
                ✕
              </button>
              <button className="swipe-button like" onClick={() => handleSwipe('right')}>
                ♡
              </button>
            </div>
          </div>

          <div className="stats">
            <p>Вподобано: {likes} • Пропущено: {dislikes}</p>
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

</body>
</html>