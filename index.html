<!DOCTYPE html>

<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Питання для друзів</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400&family=Inter:wght@400&display=swap');

```
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #faf8f6;
  color: #1a1a1a;
  font-family: 'Inter', -apple-system, sans-serif;
}

.app {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: max(env(safe-area-inset-top), 48px) 0 max(env(safe-area-inset-bottom), 48px);
}

.header {
  text-align: center;
  margin-bottom: 24px;
}

.header h1 {
  font-family: 'Inter', sans-serif;
  font-size: 0.875rem;
  font-weight: 400;
  opacity: 0.5;
  margin-bottom: 8px;
}

.header p {
  font-family: 'Inter', sans-serif;
  font-size: 0.8125rem;
  font-weight: 400;
  opacity: 0.45;
}

.question-container {
  flex: 1;
  width: 100%;
  max-width: 640px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 8vh;
  padding-left: 0;
  padding-right: 0;
  position: relative;
  touch-action: none;
}

.question-wrapper {
  width: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  transition: none;
  padding: 0;
}

.question-text {
  font-family: 'Source Serif 4', Georgia, serif;
  font-size: clamp(1.75rem, 5vw, 2.5rem);
  font-weight: 400;
  line-height: 1.4;
  text-align: center;
  width: 80%;
  margin: 0 auto 32px auto;
  padding: 0;
}

.horse-illustration {
  width: 200px;
  height: auto;
  opacity: 0;
  animation: fadeInHorse 300ms ease-out forwards;
  margin: 0 auto 32px auto;
  display: block;
}

.horse-illustration svg {
  width: 100%;
  height: auto;
}

@keyframes fadeInHorse {
  from { opacity: 0; }
  to { opacity: 1; }
}

.actions {
  display: flex;
  gap: 12px;
  justify-content: center;
  width: 100%;
  max-width: 400px;
  padding: 0 20px;
  margin: 0 auto;
}

.action-button {
  font-family: 'Inter', sans-serif;
  font-size: 0.875rem;
  font-weight: 400;
  padding: 14px 28px;
  border: 1px solid rgba(26, 26, 26, 0.15);
  background: transparent;
  cursor: pointer;
  transition: all 200ms ease;
  flex: 1;
  max-width: 180px;
}

.action-button.skip {
  color: rgba(26, 26, 26, 0.45);
  border-color: rgba(26, 26, 26, 0.12);
}

.action-button.skip:hover {
  border-color: rgba(26, 26, 26, 0.25);
  color: rgba(26, 26, 26, 0.6);
}

.action-button.discuss {
  color: #1a1a1a;
  border-color: #1a1a1a;
}

.action-button.discuss:hover {
  background: #1a1a1a;
  color: #faf8f6;
}

.action-button:active {
  transform: scale(0.98);
}

.hint {
  position: absolute;
  bottom: 24px;
  left: 0;
  right: 0;
  text-align: center;
  font-family: 'Inter', sans-serif;
  font-size: 0.8125rem;
  font-weight: 400;
  opacity: 0.4;
  transition: opacity 300ms ease-out;
}

.hint.hidden {
  opacity: 0;
  pointer-events: none;
}

.end-screen {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  max-width: 480px;
}

.end-screen h2 {
  font-family: 'Source Serif 4', Georgia, serif;
  font-size: 1.5rem;
  font-weight: 400;
  line-height: 1.4;
  margin-bottom: 24px;
}

.end-screen p {
  font-family: 'Inter', sans-serif;
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5;
  opacity: 0.7;
  margin-bottom: 48px;
}

.button {
  font-family: 'Inter', sans-serif;
  font-size: 0.9375rem;
  font-weight: 400;
  padding: 16px 32px;
  background: #1a1a1a;
  color: #faf8f6;
  border: none;
  cursor: pointer;
  margin-bottom: 16px;
  transition: opacity 200ms ease;
}

.button:hover {
  opacity: 0.85;
}

.button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.button.secondary {
  background: transparent;
  color: #1a1a1a;
  opacity: 0.5;
}

.button.secondary:hover {
  opacity: 0.7;
}

.loading-screen {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.loading-screen p {
  font-family: 'Inter', sans-serif;
  font-size: 0.9375rem;
  font-weight: 400;
  opacity: 0.6;
}
```

  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const horses = [
      // Standing horse - full body
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M100,70 Q110,60 120,65 L130,72 Q135,68 140,73 L145,82 Q150,90 155,100 L160,120 Q162,140 160,160 L155,180 L150,200 L145,190 L140,180 L135,200 L130,220 L128,240 L126,260 M145,190 L147,210 L148,230 L149,250 M100,160 L95,180 L92,200 L90,220 L88,240 M120,160 L115,185 L112,210 L110,235 L108,255" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="128" cy="75" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Walking horse
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M90,80 Q100,72 110,78 L120,85 Q125,80 132,86 L138,95 Q145,105 150,118 L155,138 Q157,155 155,172 L150,190 L145,205 L140,195 L135,185 L130,205 L125,220 L122,235 M140,195 L142,215 L143,230 M90,170 L85,190 L82,205 L80,225 M115,170 L110,195 L107,215 L105,240" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="118" cy="82" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Horse head profile
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M120,100 Q130,85 145,92 L160,105 Q165,100 172,108 L178,120 Q185,135 188,152 L185,170 Q180,182 170,188 L155,192 Q140,194 128,188 L118,178 Q110,165 108,150 L110,130 Q115,115 120,100 M155,108 L157,118 M168,115 L170,125" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="158" cy="110" r="3" fill="#1a1a1a"/>
      </svg>`,
      
      // Grazing horse
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M95,120 Q105,115 115,120 L125,128 Q130,125 137,130 L143,140 Q148,150 152,165 L155,185 Q156,200 154,215 L150,230 L145,242 L140,235 L135,228 L130,242 L125,255 M140,235 L142,250 M95,212 L90,228 L87,242 M118,212 L113,232 L110,248" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="123" cy="125" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Horse looking back
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M110,85 Q120,75 132,82 L142,92 Q148,88 155,95 L162,108 Q168,120 172,135 L175,155 Q176,172 173,188 L168,205 L163,220 L158,210 L153,200 L148,218 L143,235 L140,250 M158,210 L160,228 L161,242 M110,185 L105,205 L102,222 M130,185 L125,208 L122,228" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="140" cy="88" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Running horse
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M85,90 Q95,82 108,88 L120,98 Q126,92 135,100 L143,112 Q150,125 156,142 L160,162 Q162,178 160,194 L155,210 L150,222 L145,212 L140,202 L135,220 L130,235 M145,212 L147,228 M85,192 L80,210 L77,225 M110,192 L105,215 L102,235" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="116" cy="92" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Side view standing
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M105,75 Q115,68 125,73 L135,82 Q140,78 147,84 L153,95 Q158,105 162,118 L165,138 Q167,155 165,172 L160,190 L155,205 L150,195 L145,185 L140,205 L135,222 L132,240 M150,195 L152,215 L153,232 M105,170 L100,190 L97,210 L94,230 M125,170 L120,195 L117,218 L114,238" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="133" cy="78" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Rearing horse
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M115,110 Q125,95 138,105 L148,118 Q153,112 160,120 L165,132 Q170,145 172,160 L173,180 Q172,195 168,208 L163,220 L158,230 L153,222 L148,214 L143,230 L138,242 M153,222 L155,235 M125,205 L120,220 L117,235" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="145" cy="110" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Trotting horse
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M92,88 Q102,80 114,86 L125,95 Q131,90 139,97 L146,108 Q152,120 157,135 L161,155 Q163,172 161,188 L156,205 L151,218 L146,208 L141,198 L136,218 L131,233 L128,248 M146,208 L148,226 L149,240 M92,186 L87,205 L84,220 L81,238 M115,186 L110,210 L107,228 L104,245" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="122" cy="88" r="2" fill="#1a1a1a"/>
      </svg>`,
      
      // Young horse
      `<svg viewBox="0 0 300 300" xmlns="http://www.w3.org/2000/svg">
        <path d="M108,95 Q118,88 128,94 L138,103 Q143,98 150,105 L156,116 Q161,127 165,142 L168,162 Q170,178 168,193 L163,208 L158,220 L153,212 L148,204 L143,220 L138,235 M153,212 L155,228 M108,190 L103,208 L100,224 M128,190 L123,212 L120,230" 
        stroke="#1a1a1a" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
        <circle cx="136" cy="97" r="2.5" fill="#1a1a1a"/>
      </svg>`
    ];

    const initialQuestions = [
      // Про просте і щоденне
      { text: "Яка дрібна річ робить твій день кращим майже завжди?", category: "daily" },
      { text: "Що з простого життя ти цінуєш більше, ніж здається ззовні?", category: "daily" },
      { text: "Коли ти востаннє відчував тиху радість без особливої причини?", category: "daily" },
      { text: "Що допомагає тобі заспокоїтись, коли всередині шумно?", category: "daily" },
      { text: "Який момент за останній час хочеться згадувати знову і знову?", category: "daily" },
      { text: "Що в твоєму житті зараз дає відчуття стабільності?", category: "daily" },
      { text: "Яку частину дня ти любиш найбільше — і за що?", category: "daily" },
      { text: "Коли ти востаннє дозволив собі просто бути, без планів?", category: "daily" },
      
      // Про людей
      { text: "Хто з'явився у твоєму житті несподівано, але дуже влучно?", category: "people" },
      { text: "З ким у твоєму житті завжди трохи тепліше?", category: "people" },
      { text: "Кого ти згадуєш, коли тобі важко?", category: "people" },
      { text: "З ким тобі легко бути собою, навіть без розмов?", category: "people" },
      { text: "Яка розмова з кимось залишилась у тобі надовго?", category: "people" },
      { text: "Хто навчив тебе чомусь важливому, сам того не знаючи?", category: "people" },
      { text: "Поруч із якими людьми ти відчуваєш себе спокійно?", category: "people" },
      { text: "Коли ти востаннє відчував щиру людську підтримку?", category: "people" },
      
      // Про спогади
      { text: "Який запах або звук миттєво повертає тебе в минуле?", category: "memories" },
      { text: "Який спогад живе в тобі не образами, а відчуттям?", category: "memories" },
      { text: "Є місце, яке для тебе завжди буде \"домом\", навіть якщо ти там давно не був?", category: "memories" },
      { text: "Яку просту сцену з минулого ти часто згадуєш?", category: "memories" },
      { text: "Який період життя був тихим, але дуже важливим для тебе?", category: "memories" },
      { text: "Про який спогад ти рідко розповідаєш, але він для тебе цінний?", category: "memories" },
      { text: "Яка дрібниця з минулого досі має для тебе значення?", category: "memories" },
      { text: "Що з дитинства залишилось у тобі до сьогодні?", category: "memories" },
      
      // Про себе
      { text: "Що в собі ти навчився цінувати з часом?", category: "self" },
      { text: "Є щось, що ти довго не помічав у собі, а тепер помічаєш?", category: "self" },
      { text: "Що в тобі залишилось незмінним, попри всі зміни?", category: "self" },
      { text: "За що ти можеш бути вдячний собі сьогодні?", category: "self" },
      { text: "Що в тобі хочеться берегти?", category: "self" },
      { text: "Коли ти відчуваєш, що живеш \"правильно\" для себе?", category: "self" }
    ];

    function App() {
      const [questions, setQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [preferences, setPreferences] = useState({});
      const [showHint, setShowHint] = useState(true);
      const [isGenerating, setIsGenerating] = useState(false);
      const [isDragging, setIsDragging] = useState(false);
      const [dragY, setDragY] = useState(0);
      const [startY, setStartY] = useState(0);
      
      const QUESTIONS_PER_ROUND = 10;
      const SWIPE_THRESHOLD = 80;

      useEffect(() => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        
        const saved = localStorage.getItem('questionPreferences');
        if (saved) {
          setPreferences(JSON.parse(saved));
        }
        
        const handleKeyDown = (e) => {
          if (e.key === 'ArrowDown' || e.key === ' ') {
            e.preventDefault();
            handleNext(true);
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            handleNext(false);
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      useEffect(() => {
        if (Object.keys(preferences).length > 0) {
          localStorage.setItem('questionPreferences', JSON.stringify(preferences));
        }
      }, [preferences]);

      const recordPreference = (question, liked) => {
        const categoryScores = { ...preferences };
        if (liked) {
          categoryScores[question.category] = (categoryScores[question.category] || 0) + 1;
        }
        setPreferences(categoryScores);
        
        // Log for debugging
        console.log('Recorded preference:', {
          question: question.text,
          category: question.category,
          liked,
          currentScores: categoryScores
        });
      };

      const handleNext = (liked) => {
        if (currentIndex >= questions.length) return;
        
        setShowHint(false);
        const currentQuestion = questions[currentIndex];
        recordPreference(currentQuestion, liked);
        setCurrentIndex(prev => prev + 1);
      };

      const handleTouchStart = (e) => {
        setIsDragging(true);
        setStartY(e.touches[0].clientY);
      };

      const handleTouchMove = (e) => {
        if (!isDragging) return;
        const currentY = e.touches[0].clientY;
        const delta = currentY - startY;
        setDragY(delta * 0.7);
      };

      const handleTouchEnd = () => {
        setIsDragging(false);
        
        if (Math.abs(dragY) > SWIPE_THRESHOLD) {
          if (dragY > 0) {
            handleNext(true);
          } else {
            handleNext(false);
          }
        }
        
        setDragY(0);
      };

      const handleWheel = (e) => {
        e.preventDefault();
        if (Math.abs(e.deltaY) > 20) {
          if (e.deltaY > 0) {
            handleNext(true);
          } else {
            handleNext(false);
          }
        }
      };

      const generateNewQuestions = async () => {
        setIsGenerating(true);
        const startTime = Date.now();
        
        try {
          // Get all liked questions from this round
          const likedQuestions = [];
          const completedQuestions = questions.slice(0, currentIndex);
          
          console.log('Generating based on preferences:', preferences);
          console.log('Completed questions:', completedQuestions.length);
          
          // Sort categories by preference
          const sortedCategories = Object.entries(preferences)
            .sort((a, b) => b[1] - a[1])
            .map(([cat]) => cat);

          console.log('Preferred categories:', sortedCategories);

          // Collect actual liked questions
          for (const question of completedQuestions) {
            if (preferences[question.category] > 0) {
              likedQuestions.push(question.text);
            }
          }

          const categoryContext = sortedCategories.length > 0 
            ? `Користувач найбільше любить питання про: ${sortedCategories.join(', ')}.`
            : 'Користувач тільки почав відповідати на питання.';

          const exampleQuestions = likedQuestions.slice(0, 5);

          console.log('Sending to API - liked questions:', exampleQuestions);

          const prompt = `Ти помічник, який створює питання для розмов між друзями українською мовою.

${categoryContext}

${exampleQuestions.length > 0 ? `Ось приклади питань, які сподобались:
${exampleQuestions.map(q => `- ${q}`).join('\n')}` : ''}

Створи 10 нових унікальних питань українською мовою, які:
1. Схожі за стилем і тематикою${exampleQuestions.length > 0 ? ' на приклади вище' : ''}
2. Спокійні, вдумливі, про прості речі в житті
3. Викликають щирі розмови між друзями
4. Не повторюються з існуючими

Відповідай ТІЛЬКИ у форматі JSON масиву:
[{"text":"Питання тут?","category":"daily"}]

Використовуй ці категорії: daily, people, memories, self`;

          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) {
            console.error('API request failed:', response.status);
            throw new Error('API failed');
          }

          const data = await response.json();
          console.log('API response:', data);
          
          const responseText = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanedText = responseText.replace(/```json|```/g, '').trim();
          console.log('Cleaned response:', cleanedText);
          
          const newQuestions = JSON.parse(cleanedText);
          
          const elapsed = Date.now() - startTime;
          if (elapsed < 800) {
            await new Promise(resolve => setTimeout(resolve, 800 - elapsed));
          }
          
          if (Array.isArray(newQuestions) && newQuestions.length > 0) {
            console.log('Generated questions:', newQuestions);
            setQuestions(newQuestions.slice(0, QUESTIONS_PER_ROUND));
            setCurrentIndex(0);
            setShowHint(false);
          } else {
            throw new Error('Invalid response format');
          }
        } catch (error) {
          console.error('Generation error:', error);
          // Fallback: use preference-weighted shuffle
          const weightedQuestions = [...initialQuestions];
          
          // If we have preferences, prioritize those categories
          if (Object.keys(preferences).length > 0) {
            const sortedByPreference = weightedQuestions.sort((a, b) => {
              const scoreA = preferences[a.category] || 0;
              const scoreB = preferences[b.category] || 0;
              if (scoreA !== scoreB) return scoreB - scoreA;
              return Math.random() - 0.5;
            });
            setQuestions(sortedByPreference.slice(0, QUESTIONS_PER_ROUND));
          } else {
            const shuffled = weightedQuestions.sort(() => Math.random() - 0.5);
            setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
          }
          
          setCurrentIndex(0);
        } finally {
          setIsGenerating(false);
        }
      };

      const startNewRound = () => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        setCurrentIndex(0);
        setShowHint(false);
      };

      if (isGenerating) {
        return (
          <div className="app">
            <div className="loading-screen">
              <p>Добираємо питання для цієї розмови…</p>
            </div>
          </div>
        );
      }

      if (currentIndex >= questions.length) {
        const topCategories = Object.entries(preferences)
          .sort((a, b) => b[1] - a[1])
          .slice(0, 2)
          .map(([cat]) => {
            const names = {
              daily: 'щоденне',
              people: 'людей', 
              memories: 'спогади',
              self: 'себе'
            };
            return names[cat] || cat;
          });
        
        return (
          <div className="app">
            <div className="header">
              <h1>Питання для друзів</h1>
            </div>
            <div className="end-screen">
              <h2>Це було 10 питань.</h2>
              {topCategories.length > 0 && (
                <p>Вам найбільше зайшли теми про {topCategories.join(' та ')}.</p>
              )}
              <p>Хочеш ще — схожих на ті, що вам зайшли?</p>
              <button className="button" onClick={generateNewQuestions}>
                Згенерувати ще 10
              </button>
              <button className="button secondary" onClick={startNewRound}>
                Досить на сьогодні
              </button>
            </div>
          </div>
        );
      }

      const currentQuestion = questions[currentIndex];
      const horseIndex = currentIndex % horses.length;
      const opacity = isDragging ? Math.max(0.95, 1 - Math.abs(dragY) / 500) : 1;
      
      return (
        <div className="app">
          <div className="header">
            <h1>Питання для друзів</h1>
            <p>{currentIndex + 1} з {QUESTIONS_PER_ROUND}</p>
          </div>
          
          <div 
            className="question-container"
            onTouchStart={handleTouchStart}
            onTouchMove={handleTouchMove}
            onTouchEnd={handleTouchEnd}
            onWheel={handleWheel}
          >
            <div 
              className="question-wrapper"
              style={{
                transform: `translateY(${dragY}px)`,
                opacity: opacity,
                transition: isDragging ? 'none' : 'transform 400ms ease-out, opacity 400ms ease-out'
              }}
            >
              <div className="question-text">
                {currentQuestion?.text}
              </div>
              
              <div 
                className="horse-illustration"
                key={currentIndex}
                dangerouslySetInnerHTML={{ __html: horses[horseIndex] }}
              />
              
              <div className="actions">
                <button 
                  className="action-button skip" 
                  onClick={() => handleNext(false)}
                >
                  Nay
                </button>
                <button 
                  className="action-button discuss" 
                  onClick={() => handleNext(true)}
                >
                  Yay
                </button>
              </div>
            </div>
          </div>
          
          {showHint && (
            <div className="hint">
              Проведи вниз, щоб перейти далі
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

</body>
</html>