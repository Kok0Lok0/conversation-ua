<!DOCTYPE html>

<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Питання для друзів</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Serif+4:wght@400&family=Inter:wght@400&display=swap');

```
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #faf8f6;
  color: #1a1a1a;
  font-family: 'Inter', -apple-system, sans-serif;
}

.app {
  width: 100%;
  height: 100%;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: max(env(safe-area-inset-top), 48px) 24px max(env(safe-area-inset-bottom), 48px);
}

.header {
  text-align: center;
  margin-bottom: 24px;
}

.header h1 {
  font-family: 'Inter', sans-serif;
  font-size: 0.875rem;
  font-weight: 400;
  opacity: 0.5;
  margin-bottom: 8px;
}

.header p {
  font-family: 'Inter', sans-serif;
  font-size: 0.8125rem;
  font-weight: 400;
  opacity: 0.45;
}

.question-container {
  flex: 1;
  width: 100%;
  max-width: 640px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding-top: 10vh;
  position: relative;
  touch-action: none;
}

.question-wrapper {
  position: absolute;
  top: 10vh;
  left: 0;
  right: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  transition: none;
}

.question-text {
  font-family: 'Source Serif 4', Georgia, serif;
  font-size: clamp(1.75rem, 5vw, 2.5rem);
  font-weight: 400;
  line-height: 1.4;
  text-align: center;
  max-width: 80%;
  margin-bottom: 48px;
}

.horse-illustration {
  width: auto;
  max-height: 30vh;
  opacity: 0;
  animation: fadeInHorse 300ms ease-out forwards;
  margin-left: 12px;
}

@keyframes fadeInHorse {
  from { opacity: 0; }
  to { opacity: 1; }
}

.hint {
  position: absolute;
  bottom: 24px;
  left: 0;
  right: 0;
  text-align: center;
  font-family: 'Inter', sans-serif;
  font-size: 0.8125rem;
  font-weight: 400;
  opacity: 0.4;
  transition: opacity 300ms ease-out;
}

.hint.hidden {
  opacity: 0;
  pointer-events: none;
}

.end-screen {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  max-width: 480px;
}

.end-screen h2 {
  font-family: 'Source Serif 4', Georgia, serif;
  font-size: 1.5rem;
  font-weight: 400;
  line-height: 1.4;
  margin-bottom: 24px;
}

.end-screen p {
  font-family: 'Inter', sans-serif;
  font-size: 1rem;
  font-weight: 400;
  line-height: 1.5;
  opacity: 0.7;
  margin-bottom: 48px;
}

.button {
  font-family: 'Inter', sans-serif;
  font-size: 0.9375rem;
  font-weight: 400;
  padding: 16px 32px;
  background: #1a1a1a;
  color: #faf8f6;
  border: none;
  cursor: pointer;
  margin-bottom: 16px;
  transition: opacity 200ms ease;
}

.button:hover {
  opacity: 0.85;
}

.button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.button.secondary {
  background: transparent;
  color: #1a1a1a;
  opacity: 0.5;
}

.button.secondary:hover {
  opacity: 0.7;
}

.loading-screen {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}

.loading-screen p {
  font-family: 'Inter', sans-serif;
  font-size: 0.9375rem;
  font-weight: 400;
  opacity: 0.6;
}
```

  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // Hand-drawn horse SVGs (pencil sketch style - monochrome, imperfect lines)
    const horses = [
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M60,50 Q65,45 70,48 L75,52 Q78,48 82,52 L85,58 Q88,62 90,68 L92,80 Q93,90 92,100 L90,110 L88,120 L85,115 L82,110 L80,120 L78,130 L77,145 L76,160 L75,170 M85,115 L87,125 L88,135 L89,150 L90,165 L91,175 M60,100 L58,110 L57,125 L56,140 L55,155 L54,170 M70,100 L68,115 L67,130 L66,145 L65,160 L64,172" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M55,52 Q60,48 65,50 L70,54 Q73,50 77,54 L80,60 Q83,64 85,70 L87,82 Q88,92 87,102 L85,112 L83,122 L80,117 L77,112 L75,122 L73,132 L72,140 L71,150 M80,117 L82,127 L83,137 L84,145 L85,155 M55,102 L53,112 L52,122 L51,132 L52,145 M65,102 L63,117 L62,127 L63,140 L64,152" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M80,60 Q85,55 90,58 L95,62 Q98,58 102,62 L105,68 Q108,75 110,85 L108,95 Q105,100 100,102 L95,103 Q90,104 85,102 L80,98 Q75,92 74,85 L75,75 Q77,68 80,60 M95,62 L96,68 M102,65 L103,70" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`,
      
      `<svg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><path d="M70,55 Q75,50 80,53 L85,57 Q88,53 92,57 L95,63 Q98,67 100,73 L102,85 Q103,95 102,105 L100,115 L98,125 L95,120 L92,115 L90,125 L88,135 L87,148 L86,163 M95,120 L97,130 L98,140 L99,153 L100,165 M70,105 L68,115 L67,128 L66,143 L65,158 M80,105 L78,120 L77,135 L76,150 L75,163" stroke="#1a1a1a" stroke-width="1.5" fill="none" stroke-linecap="round" stroke-linejoin="round"/></svg>`
    ];

    const initialQuestions = [
      { text: "Коли востаннє ти робив щось вперше?", category: "experiences" },
      { text: "Яку правду про себе тобі важко визнати?", category: "self" },
      { text: "Що ти знаєш напевно, чого не можеш довести?", category: "wisdom" },
      { text: "Який страх тобі потрібно було б подолати, щоб жити повніше?", category: "fears" },
      { text: "Що змусило тебе недавно змінити думку?", category: "growth" },
      { text: "Яке рішення ти відкладаєш?", category: "decisions" },
      { text: "Коли ти відчував себе найбільш собою?", category: "identity" },
      { text: "Що ти робиш, коли ніхто не бачить?", category: "self" },
      { text: "Яке враження про себе тобі важко залишити?", category: "identity" },
      { text: "Що тебе дратує в інших, але ти бачиш це в собі?", category: "growth" },
      { text: "Який спогад відчувається нереальним?", category: "memories" },
      { text: "Що ти робив би, якби гроші не мали значення?", category: "dreams" },
      { text: "Яке питання ти боїшся поставити сам собі?", category: "fears" },
      { text: "Коли востаннє ти плакав і чому?", category: "emotions" },
      { text: "Що для тебе означає бути чесним?", category: "values" },
      { text: "Який найдивніший комплімент ти отримував?", category: "relationships" },
      { text: "Від чого ти втікаєш?", category: "fears" },
      { text: "Яку частину себе ты ховаєш від оточуючих?", category: "identity" },
      { text: "Що змінилося після того, як ты став дорослим?", category: "growth" },
      { text: "Яка думка постійно повертається до тебе?", category: "thoughts" },
      { text: "Що тобі подобається в самотності?", category: "self" },
      { text: "Який момент визначив, ким ти став?", category: "memories" },
      { text: "Що ты хочеш відчути хоча б раз?", category: "dreams" },
      { text: "Яке припущення про тебе виявилося неправильним?", category: "identity" },
      { text: "Що ты робиш інакше, ніж більшість людей?", category: "self" },
      { text: "Коли ты відчуваєш себе найбільш вразливим?", category: "emotions" },
      { text: "Що змушує тебе втрачати почуття часу?", category: "happiness" },
      { text: "Яку пораду ты даєш, але сам не дотримуєшся?", category: "wisdom" },
      { text: "Що б ты хотів сказати комусь, але не можеш?", category: "relationships" },
      { text: "Який парадокс ты помічаєш у собі?", category: "self" },
      { text: "Коли ты дозволяєш собі не бути продуктивним?", category: "life" },
      { text: "Що тебе приваблює в людях?", category: "relationships" },
      { text: "Яке місце відчувається як дім?", category: "memories" },
      { text: "Від якої звички тобі найважче відмовитися?", category: "growth" },
      { text: "Що змушує тебе почуватися незрозумілим?", category: "emotions" },
      { text: "Яку версію себе ты залишив у минулому?", category: "growth" },
      { text: "Коли тиша відчувається найголоснішою?", category: "thoughts" },
      { text: "Що тебе лякає в близькості з іншими?", category: "relationships" },
      { text: "Яке очікування від життя ты відпустив?", category: "wisdom" },
      { text: "Що тобі хочеться зрозуміти про себе?", category: "identity" },
      { text: "Яку частину дитинства ты все ще несеш у собі?", category: "memories" },
      { text: "Що ты робиш, щоб відчути себе живим?", category: "emotions" },
      { text: "Коли ты відчував найбільший сором?", category: "experiences" },
      { text: "Що б ты сказав собі п'ять років тому?", category: "wisdom" },
      { text: "Яка тиша тобі найпотрібніша?", category: "self" },
      { text: "Від чого ты не можеш відмовитися, навіть знаючи, що треба?", category: "decisions" },
      { text: "Що ты помічаєш у собі, коли тобі погано?", category: "self" },
      { text: "Яке слово описує тебе найточніше?", category: "identity" },
      { text: "Що ты хочеш пробачити собі?", category: "growth" },
      { text: "Коли востаннє ты відчував справжній спокій?", category: "emotions" },
      { text: "Яку роль ты граєш, яка тобі набридла?", category: "identity" },
      { text: "Що змушує тебе сумніватися в собі?", category: "fears" },
      { text: "Яка розмова змінила твоє життя?", category: "memories" },
      { text: "Що ты робиш, коли не можеш заснути?", category: "thoughts" },
      { text: "Від якого комплексу ты хочеш звільнитися?", category: "growth" },
      { text: "Що тебе дивує в собі?", category: "self" },
      { text: "Яке рішення ты ухвалив занадто пізно?", category: "decisions" },
      { text: "Що робить тебе вразливим у хорошому сенсі?", category: "emotions" },
      { text: "Коли ты дозволяєш собі бути слабким?", category: "self" },
      { text: "Що змінилося в тобі після болю?", category: "growth" },
      { text: "Яку правду ты уникаєш?", category: "fears" },
      { text: "Що ты робиш для себе, а не для інших?", category: "self" },
      { text: "Коли ты відчуваєш, що живеш не своє життя?", category: "identity" },
      { text: "Що ты шукаєш у відносинах?", category: "relationships" },
      { text: "Яке запитання ты хотів би почути від когось?", category: "thoughts" },
      { text: "Від чого тобі важко відпустити?", category: "emotions" },
      { text: "Що змушує тебе відчувати себе на місці?", category: "happiness" },
      { text: "Коли ты востаннє був абсолютно чесним?", category: "values" },
      { text: "Що б ты хотів, щоб про тебе знали після смерті?", category: "identity" },
      { text: "Яка тривога найчастіше тебе відвідує?", category: "fears" },
      { text: "Що ты приховуєш від себе?", category: "self" },
      { text: "Коли ты відчував справжню свободу?", category: "experiences" },
      { text: "Що тебе змушує почуватися маленьким?", category: "emotions" },
      { text: "Яке рішення ты ухвалюєш щодня, не помічаючи?", category: "thoughts" },
      { text: "Від чого залежить твоя цінність у твоїх очах?", category: "values" },
      { text: "Що ты хочеш сказати, але боїшся звучати банально?", category: "relationships" },
      { text: "Коли ты дозволяєш собі бути недосконалим?", category: "self" },
      { text: "Що змушує тебе відчувати провину?", category: "emotions" },
      { text: "Яке переконання про себе ты хочеш змінити?", category: "growth" }
    ];

    function App() {
      const [questions, setQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [preferences, setPreferences] = useState({});
      const [showHint, setShowHint] = useState(true);
      const [isGenerating, setIsGenerating] = useState(false);
      const [isDragging, setIsDragging] = useState(false);
      const [dragY, setDragY] = useState(0);
      const [startY, setStartY] = useState(0);
      
      const QUESTIONS_PER_ROUND = 10;
      const SWIPE_THRESHOLD = 80;
      
      const containerRef = useRef(null);

      useEffect(() => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        
        const saved = localStorage.getItem('questionPreferences');
        if (saved) {
          setPreferences(JSON.parse(saved));
        }
        
        const handleKeyDown = (e) => {
          if (e.key === 'ArrowDown' || e.key === ' ') {
            e.preventDefault();
            handleNext(true); // Down = next
          } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            handleNext(false); // Up = previous
          }
        };
        
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
      }, []);

      useEffect(() => {
        if (Object.keys(preferences).length > 0) {
          localStorage.setItem('questionPreferences', JSON.stringify(preferences));
        }
      }, [preferences]);

      const recordPreference = (question, liked) => {
        const categoryScores = { ...preferences };
        if (liked) {
          categoryScores[question.category] = (categoryScores[question.category] || 0) + 1;
        }
        setPreferences(categoryScores);
      };

      const handleNext = (liked) => {
        if (currentIndex >= questions.length) return;
        
        setShowHint(false);
        const currentQuestion = questions[currentIndex];
        recordPreference(currentQuestion, liked);
        setCurrentIndex(prev => prev + 1);
      };

      const handleTouchStart = (e) => {
        setIsDragging(true);
        setStartY(e.touches[0].clientY);
      };

      const handleTouchMove = (e) => {
        if (!isDragging) return;
        const currentY = e.touches[0].clientY;
        const delta = currentY - startY;
        setDragY(delta * 0.7);
      };

      const handleTouchEnd = () => {
        setIsDragging(false);
        
        if (Math.abs(dragY) > SWIPE_THRESHOLD) {
          if (dragY > 0) {
            // Swipe down = next
            handleNext(true);
          } else {
            // Swipe up = previous
            handleNext(false);
          }
        }
        
        setDragY(0);
      };

      const handleWheel = (e) => {
        e.preventDefault();
        if (Math.abs(e.deltaY) > 20) {
          if (e.deltaY > 0) {
            // Scroll down = next
            handleNext(true);
          } else {
            // Scroll up = previous
            handleNext(false);
          }
        }
      };

      const generateNewQuestions = async () => {
        setIsGenerating(true);
        const startTime = Date.now();
        
        try {
          const sortedCategories = Object.entries(preferences)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([cat]) => cat);

          const categoryContext = sortedCategories.length > 0 
            ? `Користувач найбільше любить питання про: ${sortedCategories.join(', ')}.`
            : '';

          const likedQuestionExamples = questions
            .filter(q => sortedCategories.includes(q.category))
            .slice(0, 5)
            .map(q => q.text);

          const prompt = `Ти помічник, який створює питання для розмов між друзями українською мовою.

${categoryContext}

Ось приклади питань, які сподобались користувачу:
${likedQuestionExamples.map(q => `- ${q}`).join('\n')}

Створи 10 нових унікальних питань українською мовою для друзів, які:
1. Схожі за стилем і тематикою на приклади вище
2. Конкретні, не абстрактні чи загальні
3. Викликають вдумливі, особисті відповіді
4. Уникають кліше
5. Можуть бути дещо незручними, але в хорошому сенсі

ВАЖЛИВО: Відповідай ТІЛЬКИ у форматі JSON масиву. Формат:
[{"text":"Питання?","category":"dreams"}]

Категорії: dreams, life, experiences, fears, memories, relationships, growth, happiness, wisdom, identity, emotions, values, self, decisions, thoughts`;

          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [{ role: 'user', content: prompt }]
            })
          });

          if (!response.ok) throw new Error('API failed');

          const data = await response.json();
          const responseText = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanedText = responseText.replace(/```json|```/g, '').trim();
          const newQuestions = JSON.parse(cleanedText);
          
          const elapsed = Date.now() - startTime;
          if (elapsed < 800) {
            await new Promise(resolve => setTimeout(resolve, 800 - elapsed));
          }
          
          if (Array.isArray(newQuestions) && newQuestions.length > 0) {
            setQuestions(newQuestions.slice(0, QUESTIONS_PER_ROUND));
            setCurrentIndex(0);
            setShowHint(false);
          }
        } catch (error) {
          const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
          setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
          setCurrentIndex(0);
        } finally {
          setIsGenerating(false);
        }
      };

      const startNewRound = () => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        setCurrentIndex(0);
        setShowHint(false);
      };

      if (isGenerating) {
        return (
          <div className="app">
            <div className="loading-screen">
              <p>Добираємо питання для цієї розмови…</p>
            </div>
          </div>
        );
      }

      if (currentIndex >= questions.length) {
        return (
          <div className="app">
            <div className="header">
              <h1>Питання для друзів</h1>
            </div>
            <div className="end-screen">
              <h2>Це було 10 питань.</h2>
              <p>Хочеш ще — схожих на ті, що вам зайшли?</p>
              <button className="button" onClick={generateNewQuestions}>
                Згенерувати ще 10
              </button>
              <button className="button secondary" onClick={startNewRound}>
                Досить на сьогодні
              </button>
            </div>
          </div>
        );
      }

      const currentQuestion = questions[currentIndex];
      const horseIndex = currentIndex % horses.length;
      const opacity = isDragging ? Math.max(0.95, 1 - Math.abs(dragY) / 500) : 1;
      
      return (
        <div className="app">
          <div className="header">
            <h1>Питання для друзів</h1>
            <p>{currentIndex + 1} з {QUESTIONS_PER_ROUND}</p>
          </div>
          
          <div 
            ref={containerRef}
            className="question-container"
          >
            <div 
              className="question-wrapper"
              onTouchStart={handleTouchStart}
              onTouchMove={handleTouchMove}
              onTouchEnd={handleTouchEnd}
              onWheel={handleWheel}
              style={{
                transform: `translateY(${dragY}px)`,
                opacity: opacity,
                transition: isDragging ? 'none' : 'transform 400ms ease-out, opacity 400ms ease-out'
              }}
            >
              <div className="question-text">
                {currentQuestion?.text}
              </div>
              
              <div 
                className="horse-illustration"
                key={currentIndex}
                dangerouslySetInnerHTML={{ __html: horses[horseIndex] }}
              />
            </div>
          </div>
          
          {showHint && (
            <div className="hint">
              Проведи вниз, щоб перейти далі
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

</body>
</html>