<!DOCTYPE html>

<html lang="uk">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Питання для друзів</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap');

```
:root {
  --bg-primary: #0a0a0a;
  --bg-card: #1a1a1a;
  --text-primary: #ffffff;
  --text-secondary: #6b6b6b;
  --border: rgba(255, 255, 255, 0.08);
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  min-height: 100vh;
  -webkit-font-smoothing: antialiased;
}

.container {
  max-width: 440px;
  margin: 0 auto;
  padding: 60px 20px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.header {
  text-align: center;
  margin-bottom: 60px;
}

.header h1 {
  font-size: 1.5rem;
  font-weight: 500;
  color: var(--text-primary);
  margin-bottom: 12px;
  letter-spacing: -0.01em;
}

.header p {
  font-size: 0.875rem;
  color: var(--text-secondary);
  font-weight: 400;
}

.card-container {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  margin-bottom: 48px;
}

.question-card {
  width: 100%;
  max-width: 400px;
  min-height: 500px;
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 64px 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  position: relative;
  user-select: none;
}

.question-card:hover {
  border-color: rgba(255, 255, 255, 0.12);
}

.question-text {
  font-size: 1.375rem;
  line-height: 1.6;
  color: var(--text-primary);
  font-weight: 400;
  letter-spacing: -0.01em;
}

.controls {
  display: flex;
  justify-content: center;
  gap: 12px;
  margin-bottom: 24px;
}

.swipe-button {
  flex: 1;
  max-width: 180px;
  padding: 16px 24px;
  border-radius: 12px;
  font-size: 0.875rem;
  font-weight: 500;
  border: 1px solid var(--border);
  background: transparent;
  color: var(--text-primary);
  cursor: pointer;
  transition: all 0.2s ease;
}

.swipe-button:hover {
  border-color: rgba(255, 255, 255, 0.2);
}

.swipe-button:active {
  transform: scale(0.98);
}

.swipe-button.like {
  background: var(--text-primary);
  color: var(--bg-primary);
  border-color: var(--text-primary);
}

.swipe-button.like:hover {
  opacity: 0.9;
}

.end-screen {
  max-width: 360px;
  margin: 0 auto;
  text-align: center;
}

.end-description {
  font-size: 1rem;
  line-height: 1.6;
  color: var(--text-secondary);
  margin-bottom: 32px;
}

.button {
  display: block;
  width: 100%;
  padding: 16px 24px;
  font-size: 0.875rem;
  font-weight: 500;
  font-family: 'Inter', sans-serif;
  background: var(--text-primary);
  color: var(--bg-primary);
  border: none;
  border-radius: 12px;
  cursor: pointer;
  transition: opacity 0.2s ease;
  margin-bottom: 12px;
}

.button:hover {
  opacity: 0.9;
}

.button:disabled {
  background: var(--bg-card);
  color: var(--text-secondary);
  cursor: not-allowed;
  opacity: 1;
}

.button.secondary {
  background: transparent;
  color: var(--text-primary);
  border: 1px solid var(--border);
}

.button.secondary:hover {
  border-color: rgba(255, 255, 255, 0.2);
  opacity: 1;
}

@media (max-width: 480px) {
  .container {
    padding: 40px 16px;
  }
  
  .header {
    margin-bottom: 48px;
  }
  
  .header h1 {
    font-size: 1.25rem;
  }
  
  .question-text {
    font-size: 1.25rem;
  }
  
  .question-card {
    min-height: 450px;
    padding: 48px 32px;
  }
}
```

  </style>
</head>
<body>
  <div id="root"></div>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>

  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    const initialQuestions = [
      // Простi радощі
      { text: "Яка дрібна річ робить твій день кращим майже завжди?", category: "happiness" },
      { text: "Що з простого життя ти цінуєш більше, ніж здається ззовні?", category: "values" },
      { text: "Коли ти востаннє відчував тиху радість без особливої причини?", category: "emotions" },
      { text: "Що допомагає тобі заспокоїтись, коли всередині шумно?", category: "self" },
      { text: "Який момент за останній час хочеться згадувати знову і знову?", category: "memories" },
      { text: "Що в твоєму житті зараз дає відчуття стабільності?", category: "life" },
      { text: "Яку частину дня ти любиш найбільше — і за що?", category: "happiness" },
      { text: "Коли ти востаннє дозволив собі просто бути, без планів?", category: "self" },
      
      // Люди
      { text: "Хто з'явився у твоєму житті несподівано, але дуже влучно?", category: "relationships" },
      { text: "З ким у твоєму житті завжди трохи тепліше?", category: "relationships" },
      { text: "Кого ти згадуєш, коли тобі важко?", category: "relationships" },
      { text: "З ким тобі легко бути собою, навіть без розмов?", category: "relationships" },
      { text: "Яка розмова з кимось залишилась у тобі надовго?", category: "memories" },
      { text: "Хто навчив тебе чомусь важливому, сам того не знаючи?", category: "wisdom" },
      { text: "Поруч із якими людьми ти відчуваєш себе спокійно?", category: "relationships" },
      { text: "Коли ти востаннє відчував щиру людську підтримку?", category: "emotions" },
      
      // Спогади
      { text: "Який запах або звук миттєво повертає тебе в минуле?", category: "memories" },
      { text: "Який спогад живе в тобі не образами, а відчуттям?", category: "memories" },
      { text: "Є місце, яке для тебе завжди буде \"домом\", навіть якщо ти там давно не був?", category: "memories" },
      { text: "Яку просту сцену з минулого ти часто згадуєш?", category: "memories" },
      { text: "Який період життя був тихим, але дуже важливим для тебе?", category: "growth" },
      { text: "Про який спогад ти рідко розповідаєш, але він для тебе цінний?", category: "memories" },
      { text: "Яка дрібниця з минулого досі має для тебе значення?", category: "values" },
      { text: "Що з дитинства залишилось у тобі до сьогодні?", category: "memories" },
      
      // Про себе
      { text: "Що в собі ти навчився цінувати з часом?", category: "growth" },
      { text: "Є щось, що ти довго не помічав у собі, а тепер помічаєш?", category: "self" },
      { text: "Що в тобі залишилось незмінним, попри всі зміни?", category: "identity" },
      { text: "За що ти можеш бути вдячний собі сьогодні?", category: "self" },
      { text: "Що в тобі хочеться берегти?", category: "values" },
      { text: "Коли ти відчуваєш, що живеш \"правильно\" для себе?", category: "identity" }
    ];

    function App() {
      const [questions, setQuestions] = useState([]);
      const [currentIndex, setCurrentIndex] = useState(0);
      const [preferences, setPreferences] = useState({});
      const [isGenerating, setIsGenerating] = useState(false);
      
      const QUESTIONS_PER_ROUND = 10;

      useEffect(() => {
        const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
        setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        
        const saved = localStorage.getItem('questionPreferences');
        if (saved) {
          setPreferences(JSON.parse(saved));
        }
      }, []);

      useEffect(() => {
        if (Object.keys(preferences).length > 0) {
          localStorage.setItem('questionPreferences', JSON.stringify(preferences));
        }
      }, [preferences]);

      const recordPreference = (question, liked) => {
        const categoryScores = { ...preferences };
        
        if (liked) {
          categoryScores[question.category] = (categoryScores[question.category] || 0) + 1;
        }
        
        setPreferences(categoryScores);
      };

      const handleAnswer = (liked) => {
        const currentQuestion = questions[currentIndex];
        recordPreference(currentQuestion, liked);
        setCurrentIndex(prev => prev + 1);
      };

      const generateNewQuestions = async () => {
        setIsGenerating(true);
        
        try {
          const sortedCategories = Object.entries(preferences)
            .sort((a, b) => b[1] - a[1])
            .slice(0, 5)
            .map(([cat]) => cat);

          const categoryContext = sortedCategories.length > 0 
            ? `Користувач найбільше любить питання про: ${sortedCategories.join(', ')}.`
            : '';

          const likedQuestionExamples = [];
          for (let i = 0; i < questions.length; i++) {
            const q = questions[i];
            if (sortedCategories.includes(q.category)) {
              likedQuestionExamples.push(q.text);
            }
          }

          const sampleQuestions = likedQuestionExamples.slice(0, 5);

          const prompt = `Ти помічник, який створює питання для розмов між друзями українською мовою.

${categoryContext}

Ось приклади питань, які сподобались користувачу:
${sampleQuestions.map(q => `- ${q}`).join('\n')}

Створи 10 нових унікальних питань українською мовою для друзів, які:
1. Схожі за стилем і тематикою на приклади вище
2. Конкретні, не абстрактні чи загальні
3. Викликають вдумливі, особисті відповіді
4. Уникають кліше на зразок "найбільший страх" або "найщасливіший момент"
5. Можуть бути дещо незручними, але в хорошому сенсі
6. Змушують замислитися про себе по-новому

Приклади хороших питань:
- "Коли востаннє ти робив щось вперше?"
- "Яку правду про себе тобі важко визнати?"
- "Що тебе дратує в інших, але ти бачиш це в собі?"

Приклади поганих питань (уникай таких):
- "Яка твоя найбільша мрія?"
- "Що б ти змінив у житті?"
- "Який твій найщасливіший спогад?"

ВАЖЛИВО: Відповідай ТІЛЬКИ у форматі JSON масиву об'єктів, без жодного додаткового тексту, пояснень чи markdown коду. Формат:
[{"text":"Питання тут?","category":"dreams"},{"text":"Ще питання?","category":"life"}]

Використовуй ці категорії: dreams, life, experiences, fears, memories, relationships, growth, happiness, wisdom, identity, emotions, values, self, decisions, thoughts`;

          console.log('Sending request to API...');
          
          const response = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 1000,
              messages: [
                { role: 'user', content: prompt }
              ]
            })
          });

          console.log('Response status:', response.status);
          
          if (!response.ok) {
            throw new Error(`API request failed with status ${response.status}`);
          }

          const data = await response.json();
          console.log('API response:', data);
          
          const responseText = data.content
            .filter(item => item.type === 'text')
            .map(item => item.text)
            .join('');

          const cleanedText = responseText
            .replace(/```json/g, '')
            .replace(/```/g, '')
            .trim();

          console.log('Cleaned response:', cleanedText);

          const newQuestions = JSON.parse(cleanedText);
          
          if (Array.isArray(newQuestions) && newQuestions.length > 0) {
            setQuestions(newQuestions.slice(0, QUESTIONS_PER_ROUND));
            setCurrentIndex(0);
          } else {
            throw new Error('Invalid response format');
          }
        } catch (error) {
          console.error('Detailed error:', error);
          alert(`Помилка генерації: ${error.message}\n\nДля роботи AI генерації потрібно розгорнути додаток на Vercel. Зараз використовуйте "Новий раунд" для нових питань.`);
        } finally {
          setIsGenerating(false);
        }
      };

      const startNewRound = () => {
        const availableQuestions = initialQuestions.filter(q => 
          !questions.includes(q)
        );
        
        if (availableQuestions.length < QUESTIONS_PER_ROUND) {
          const shuffled = [...initialQuestions].sort(() => Math.random() - 0.5);
          setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        } else {
          const shuffled = availableQuestions.sort(() => Math.random() - 0.5);
          setQuestions(shuffled.slice(0, QUESTIONS_PER_ROUND));
        }
        
        setCurrentIndex(0);
      };

      if (currentIndex >= questions.length) {
        return (
          <div className="container">
            <div className="header">
              <h1>Раунд завершено</h1>
              <p>Ви переглянули {QUESTIONS_PER_ROUND} питань</p>
            </div>
            <div className="end-screen">
              <p className="end-description">
                Продовжити з новими питаннями на основі ваших вподобань, 
                або почати інший раунд.
              </p>
              
              <button 
                onClick={generateNewQuestions}
                disabled={isGenerating}
                className="button"
              >
                {isGenerating ? 'Готую питання...' : 'Згенерувати на основі вподобань'}
              </button>

              <button 
                onClick={startNewRound}
                className="button secondary"
              >
                Новий раунд
              </button>
            </div>
          </div>
        );
      }

      const currentQuestion = questions[currentIndex];

      return (
        <div className="container">
          <div className="header">
            <h1>Питання для друзів</h1>
            <p>{currentIndex + 1} з {QUESTIONS_PER_ROUND}</p>
          </div>

          <div className="card-container">
            <div className="question-card">
              <div className="question-text">
                {currentQuestion?.text}
              </div>
            </div>
          </div>

          <div className="controls">
            <button className="swipe-button dislike" onClick={() => handleAnswer(false)}>
              Пропустити
            </button>
            <button className="swipe-button like" onClick={() => handleAnswer(true)}>
              Обговорити
            </button>
          </div>
        </div>
      );
    }

    ReactDOM.render(<App />, document.getElementById('root'));
  </script>

</body>
</html>